(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{498:function(t,v,_){"use strict";_.r(v);var a=_(4),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"运输层是整个网络体系结构中的关键层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运输层是整个网络体系结构中的关键层"}},[t._v("#")]),t._v(" 运输层是整个网络体系结构中的关键层")]),t._v(" "),_("p",[t._v("传输层主要有 TCP 传输控制协议和 UDP 用户数据报协议，TCP 的可靠传输原理和 TCP 的滑动窗口，流量控制，拥塞机制")]),t._v(" "),_("p",[t._v("通过本文章我们需要弄清楚以下概念")]),t._v(" "),_("ol",[_("li",[t._v("运输层为相互通信的进程提供逻辑通信")]),t._v(" "),_("li",[t._v("端口和套接字的意义")]),t._v(" "),_("li",[t._v("面向无连接的 UDP 的特点")]),t._v(" "),_("li",[t._v("面向有连接的 TCP 的特点")]),t._v(" "),_("li",[t._v("在不可靠的网络上实现可靠的传输原理，停止等待协议和 AR 协议")]),t._v(" "),_("li",[t._v("TCP 的滑动窗口，流量控制，拥塞机制，连接管理")])]),t._v(" "),_("h2",{attrs:{id:"进程之间的通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程之间的通信"}},[t._v("#")]),t._v(" 进程之间的通信")]),t._v(" "),_("p",[_("em",[t._v("通信真正的终点不是主机，而是主机的进程，端到端的通信是进程与进程之间的通信，运输层有个很重要的特点是复用和分用")])]),t._v(" "),_("p",[_("em",[t._v("复用")]),t._v(" 是指不同进程可以使用同一个传输层进行传输数据\n"),_("em",[t._v("分用")]),t._v(" 是指传输层可以将数据报文传递给目的进程")]),t._v(" "),_("h2",{attrs:{id:"运输层的两个主要协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运输层的两个主要协议"}},[t._v("#")]),t._v(" 运输层的两个主要协议")]),t._v(" "),_("ol",[_("li",[t._v("用户数据报协议 UDP (user datagram protocol)")]),t._v(" "),_("li",[t._v("传输控制协议 TCP（transmission control protocol）")])]),t._v(" "),_("p",[t._v("UDP 不需要先建立连接，远程主机在收到 UDP 用户数据报时不需要给出任何确认信息，UDP 虽然是不可靠连接，但是在某些场景下是一种最有效的工作方式")]),t._v(" "),_("p",[t._v("TCP 是面向连接的服务，在传输数据之前必须先建立连接， 数据传输完成之后要释放连接，由于必须建立连接，因此会带来更多的开销，确认，流量控制，计时器，连接管理等问题，会使得协议数据单元的首部增大，增加处理机的资源")]),t._v(" "),_("h3",{attrs:{id:"运输层的端口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运输层的端口"}},[t._v("#")]),t._v(" 运输层的端口")]),t._v(" "),_("p",[t._v("协议端口号可以解决传输层的分用的功能，TCP/IP 传输层用一个 16 位(2 个字节)端口号，端口号分为两类：")]),t._v(" "),_("ol",[_("li",[t._v("服务端使用的端口号，此类端口号又分为两类 （一个是系统端口号 0-1024，一个是登记端口号 1024-49151）")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s1.ax1x.com/2022/04/15/L32aHs.png",alt:"常见的系统端口号"}})]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("客户端使用的端口号 （49151-65535）")])]),t._v(" "),_("h2",{attrs:{id:"用户数据报-udp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#用户数据报-udp"}},[t._v("#")]),t._v(" 用户数据报 UDP")]),t._v(" "),_("ol",[_("li",[t._v("UDP 是面向无连接的，尽最大努力交付的")]),t._v(" "),_("li",[t._v("UDP 没有拥塞机制，它是面向报文的")]),t._v(" "),_("li",[t._v("UDP 支持一对多，一对一，多对一，多对多的通信方式")])]),t._v(" "),_("h2",{attrs:{id:"传输控制层-tcp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#传输控制层-tcp"}},[t._v("#")]),t._v(" 传输控制层 TCP")]),t._v(" "),_("ol",[_("li",[t._v("TCP 是面向连接的，可靠的，全双工通信，面向字节流的")]),t._v(" "),_("li",[t._v("TCP 的连接的端点叫做套接字(socket) 或者插口，端口号拼接到 IP 地址即位套接字\n套接字 socket = IP 地址:端口号")])]),t._v(" "),_("h3",{attrs:{id:"可靠传输的原理是靠确认和重传机制来实现的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#可靠传输的原理是靠确认和重传机制来实现的"}},[t._v("#")]),t._v(" 可靠传输的原理是靠确认和重传机制来实现的")]),t._v(" "),_("h4",{attrs:{id:"我们先从停止等待协议开始说起"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#我们先从停止等待协议开始说起"}},[t._v("#")]),t._v(" 我们先从停止等待协议开始说起")]),t._v(" "),_("p",[t._v("停止等待协议就是，每发送一个分组就停止，等待对方确认，收到确认之后在发送下一个分组")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s1.ax1x.com/2022/04/15/L3b0UO.png",alt:"停止等待协议"}})]),t._v(" "),_("p",[t._v("在无差错的情况下，发送方 A 和接收方 B 这种传递方式是没有问题的\n在有差错的情况下，如果发送方 A 发送的分组 M1 在网络中因为延时没有及时被接收方 B 接收，因此 B 不会做任何处理，"),_("strong",[t._v("可靠的传输协议原理是这样的：A 只要在超过一段时间没有收到确认信息就认为刚刚发送的分组丢失，因此重新发送刚刚的分组，这叫超时重传，还需要设置一个超时计时器")])]),t._v(" "),_("ol",[_("li",[t._v("在 A 发送一个分组时必须保存当前分组的副本")]),t._v(" "),_("li",[t._v("分组和确认分组都必须进行编号，这样才能确认哪个分组确认被接收")]),t._v(" "),_("li",[t._v("超时重传计时器的时间需要比平均往返时间要长一些")])]),t._v(" "),_("h5",{attrs:{id:"确认丢失和确认迟到"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#确认丢失和确认迟到"}},[t._v("#")]),t._v(" 确认丢失和确认迟到")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s1.ax1x.com/2022/04/15/L3XGo6.png",alt:"确认丢失和确认迟到"}})]),t._v(" "),_("h5",{attrs:{id:"信道利用率"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#信道利用率"}},[t._v("#")]),t._v(" 信道利用率")]),t._v(" "),_("p",[t._v("停止等待协议的信道利用率太低了，每次只能发送一个分组，因此我们可以使用流水线的方式，每次传输多个分组，不必等待每个分组都被确认下来才发送下个分组，这使得信道上时刻都有分组在传输，提高了信道的利用率，这种模式叫做滑动窗口协议或者叫做连续 ARQ 协议")]),t._v(" "),_("h2",{attrs:{id:"连续的-arq-协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#连续的-arq-协议"}},[t._v("#")]),t._v(" 连续的 ARQ 协议")]),t._v(" "),_("p",[t._v("滑动窗口协议比较复杂是 TCP 的核心之一，连续的 ARQ 协议规定，发送方每收到确认一个确认分组就把滑动窗口向前移动一个分组位置，接收方是累积确认的分组的方式，不必在每个分组都给一个确认分组信息，而是在接收到几个分组之后，对按次序到达的最后一个分组发送确认，表示这个分组为止的所有分组都确认收到了。")]),t._v(" "),_("h2",{attrs:{id:"tcp-报文段的格式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-报文段的格式"}},[t._v("#")]),t._v(" TCP 报文段的格式")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s1.ax1x.com/2022/04/13/LKBdWq.png",alt:"TCP报文段的格式"}})]),t._v(" "),_("p",[t._v("各个字段的含义：")]),t._v(" "),_("ol",[_("li",[t._v("源端口号和目的端口号：各占两个字节")]),t._v(" "),_("li",[t._v("序号：占 4 个字节序号范围是 [0, 2^31-1] 一共 2^32 个序号循环，序号到 2^32 之后又返回 0， 例如："),_("em",[t._v("一段报文的序号是 301，携带 100 个字节的数据，那么这个报文的数据第一个字节的序号是 301，最后一个字节的序号是 400")])]),t._v(" "),_("li",[t._v("确认号：占 4 个字节，期望对方下一个报文段第一个数据字节开始的序号， 确认号为 N，那么 N-1 的数据字节都已被确认收到")]),t._v(" "),_("li",[t._v("数据偏移就是 TCP 报文段的数据离 TCP 报文段的起始位置有多远，其实就是表示首部的长度")]),t._v(" "),_("li",[t._v("确认 ACK: 仅当 ACK=1 时，确认号才有效，当 ACK=0 时，确认号无效。当建立连接之后，所有的报文段的 ACK 都应该置为 1")]),t._v(" "),_("li",[t._v("同步 SYN：在连接建立时用来同步序号，当 SYN=1 而 ACK=0 时，表示这是一个连接请求报文段，若对方同意连接，则在响应报文段中使用 SYN=1，ACK=1，因此 SYN=1 是一个连接请求或者是一个连接接受报文")]),t._v(" "),_("li",[t._v("终止 FIN：用来释放一个连接，当 FIN=1 时，表示数据发送完毕，可以释放连接")])]),t._v(" "),_("h2",{attrs:{id:"tcp-的可靠传输的实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-的可靠传输的实现"}},[t._v("#")]),t._v(" TCP 的可靠传输的实现")]),t._v(" "),_("p",[t._v("假定数据传输只在一个方向进行，简化讨论模型，A 是数据发送方，B 是数据接收方")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s1.ax1x.com/2022/04/15/L8DmNT.png",alt:"滑动窗口简单数据模型"}})]),t._v(" "),_("h2",{attrs:{id:"tcp-的连接管理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-的连接管理"}},[t._v("#")]),t._v(" TCP 的连接管理")]),t._v(" "),_("p",[t._v("TCP 是面向连接的协议，TCP 的连接的建立和释放是每次面向连接的通信中必不可少的过程，传输连接有三个阶段：建立连接、传输数据、释放连接。")]),t._v(" "),_("p",[_("strong",[t._v("TCP 的连接的建立")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s1.ax1x.com/2022/04/15/L8gmU1.png",alt:"TCP建立连接的过程"}}),t._v("\n一开始两端都处于 closed 的状态, 服务器被动打开处于 listen 监听状态。")]),t._v(" "),_("p",[t._v("(1) 当 A 要请求连接时, 向服务器发送一个连接请求报文段, 这时首部中的同步位 SYN=1, 同时选择一个初始序号 seq=x, 此时客户端处于 syn-sent 同步等待状态")]),t._v(" "),_("p",[t._v("(2) 服务器收到请求报文之后，同意建立连接，发送一个确认报文段，确认报文段中的 SYN=1 和 ACK=1,确认号是 ack=x+1, 同时初始化一个服务器端的序号 seq=y，此时服务器处于 syn-rcvd 同步收到状态")]),t._v(" "),_("p",[t._v("(3) 客户端收到确认报文段之后，还要向服务端给出确认连接报文段，确认报文段的 ACK=1，确认号 ack=y+1, 序号 seq=x+1, 此时处于 established 状态，已经建立连接的状态。\n"),_("em",[t._v("为什么要多一次确认，主要是防止已失效的连接请求报文段突然又传递到了服务器，如果客户端不用确认连接报文的话，那么服务器一直处于连接状态，浪费了网络资源，因此必须客户端要发送一次确认连接的报文，这就是三次握手的全过程")])]),t._v(" "),_("p",[_("strong",[t._v("TCP 连接的释放")])]),t._v(" "),_("p",[t._v("连接释放的过程比较复杂，数据传输完之后，需要释放连接，现在客户端和服务端都处于 established 已确定连接的状态。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s1.ax1x.com/2022/04/15/L8T1YQ.png",alt:"TCP连接释放的过程"}})]),t._v(" "),_("p",[t._v("（1）客户端先向服务器发送连接释放报文段，同时停止发送数据主动关闭 TCP 连接，客户端把释放报文段中的终止控制位 FIN 置为 1，序号 seq=u, 此时客户端处于终止等待的过程。")]),t._v(" "),_("p",[t._v("（2）服务端收到连接释放报文段之后,同意释放连接,发送确认释放连接报文段,确认号是 ack=u+1,同时自己的序号是 seq=v, 确认控制 ACK=1，此时服务端处于等待关闭的状态，"),_("em",[t._v("至此客户端到服务端的这条连接处于释放状态，整个连接处于半关闭状态")])]),t._v(" "),_("p",[t._v("（3）半关闭的状态会持续一段时间，等到客户端收到确认释放连接时客户端就处于终止等待 2 阶段，等待服务器发送释放报文段。")]),t._v(" "),_("p",[t._v("（4）等到服务器没有要向客户端发送的数据时，服务端向客户端发送一个释放报文段，终止控制位 FIN 置为 1，确认位 ACK=1，序号为 seq=w, 确认号 ack=u+1,这时服务端进入最后确认状态")]),t._v(" "),_("p",[t._v("（5）客户端收到服务端的释放连接报文段时，发送一个确认报文段，此时确认位 ACK=1，序号为 seq=u+1, 确认号为 ack=w+1，此时客户段处于时间等待的状态，此刻不是立马就关闭连接，必须等待 2MSL 时间，MSL 是最长报文段寿命，因此客户端要经历等待 2MSL 才能关闭 "),_("em",[t._v("需要等待 2MSL 的理由有两个，一是为了保证客户端最后一个报文段能够送达服务端，如果服务端因为网络原因没有收到客户端的最后一个释放连接的报文段，因此会出发超时重传机制，因此客户端又可以发送最后一次释放连接的报文段。 第二个是防止失效的连接请求在次出现在本连接中")])])])}),[],!1,null,null,null);v.default=s.exports}}]);